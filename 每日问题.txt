    问题：输出最大蓄水量
    输入：[1,8,6,2,5,4,8,3,7]
    数组元素表示柱子
    输出：49


思路一 暴力遍历
思路二 递归动态规划
思路三 双指针



问题：如何计算 字符串"2/3+3-4*5"
进阶：有括号"(1+2)*3"


问题 在数组中寻找和为0的三个数，不能重复
例如 {0,0,0,0,0,-1,1}
{0,0,0}//虽然有四个零但是只能算一次
{-1,0,1}

思路1双指针

首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，
数字分别为 nums[L] 和 nums[R]，计算三个数的和 sumsum 判断是否满足为 0，满足则添加进结果集
如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环
如果 nums[i] == nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过
当 sum== 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++
当 sum == 0 时，nums[R] == nums[R-1] 则会导致结果重复，应该跳过，R--
时间复杂度：O(n^2)+O(logn)


思路二 使用一个哈希map数组

map[0][0]存放0
map[-1][1]存放0
。。。。。
对于每两个数存一个map
然后遍历一遍map然后去重

时间复杂度O(n^3)


问题进阶 在数组中寻找和为targetrt的四个数，不能重复
例如
     nums = [1, 0, -1, 0, -2, 2]，和 target = 0
满足要求的四元组集合为：
   [
     [-1,  0, 0, 1],
     [-2, -1, 1, 2],
     [-2,  0, 0, 2]
   ]

问题进阶在数组中寻找和为targetrt的所有数，不能重复

必须把所有可能的解求出
例如[0,0,0,0,1,-1] target=0
    [
        [0]
        [0,0],[-1,1]
        [0,0,0],[-1,0,1]
        [0,0,0,0],[-1,0,0,1]
        [-1,0,0,0,1]
        [-1,0,0,0,0,1]
    ]




 问题 求矩阵最大面积




 问题 对比两棵树是否相等
 进阶 验证二叉搜索树
 进阶 在二叉搜索树里查找value=key的子树
 进阶 在二叉搜索树里插入子树
 进阶 在二叉搜索树里删除子树

 c++树结构体
 struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };


 问题1 先序遍历两棵树
 问题2 先序遍历判断大小
 问题3 先序遍历判断大小返回子树
 问题4 先序遍历判断插入位置，因为插入肯定是在最底层的子树
 问题5 先序遍历判断删除位置，判断左子树和右子树是否为空，
 左子树为空，删除然后将右子树接到树里，反之亦然，
 若左子树和右子树不为空，则选取左子树最大或右子树最小



  问题：知乎面试题
     升序排序的数组在预先未知的某个点上进行了旋转。
     然后找最小值
     你可以假设数组中不存在重复元素。 

     例如
     1 2 3 4 5 6 7 8 9 10 11
     旋转后
     9 10 11 1 2 3 4 5 6 7 8




	问题1 如何求一棵树的深度
	问题2 如何求一棵树的任意节点的深度
	问题3 判断一棵树是否是对称的
	问题4 一棵树的所有路径中是否有满足路径长度为val的
	
	问题1 自顶向下遍历（先序遍历）
	问题2 自底向上遍历（后续遍历）
	问题3 思路一 递归dfs
	      思路二 迭代bfs
	问题4 思路一 递归dfs
	      思路二 迭代bfs
	
	
	

	问题1 从前序与中序遍历序列构造二叉树
	问题2 从中序与后序遍历序列构造二叉树





	先序   preorder = [3,9,20,15,7]



	中序   inorder = [9,3,15,20,7]



	后序   postorder = [9,15,7,20,3]









































