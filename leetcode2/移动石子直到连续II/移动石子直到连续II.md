#### [1040. 移动石子直到连续 II](https://leetcode-cn.com/problems/moving-stones-until-consecutive-ii/)

难度中等

在一个长度**无限**的数轴上，第 `i` 颗石子的位置为 `stones[i]`。如果一颗石子的位置最小/最大，那么该石子被称作**端点石子**。

每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。

值得注意的是，如果石子像 `stones = [1,2,5]` 这样，你将**无法**移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。

当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。

要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：`answer = [minimum_moves, maximum_moves]` 。

 

**示例 1：**

```
输入：[7,4,9]
输出：[1,2]
解释：
我们可以移动一次，4 -> 8，游戏结束。
或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。
```

**示例 2：**

```
输入：[6,5,4,3,10]
输出：[2,3]
解释：
我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。
```

**示例 3：**

```
输入：[100,101,104,102,103]
输出：[0,0]
```

 

**提示：**

1. `3 <= stones.length <= 10^4`
2. `1 <= stones[i] <= 10^9`
3. `stones[i]` 的值各不相同。



------

思路：首先要读懂题目，首先输入的数组的顺序并不是排好序的，题目要求我们每次都从两个端点选取一个将其移动，使其不成为端点，直到无法移动。

由题意可知，每进行一轮操作，石子的左右端点的距离会缩短，一轮一轮收敛。最后会石子都紧邻游戏结束。

首先我们求最大移动次数，那么只要有空位，每次移动一个位置，那么就可以达到最大次数，但是第一次移动会将移动的石子与它相邻的石子之间的空位失效。

例如：

3，6，7，13

空位为13-3+1-4=7   但是移动3到12，使得3到6之间两个位置失效，那么真正的空位只有7-2=5

那么最大值max为：

```go
max:=stones[n-1]-stones[0]+1-n
max-=tomin((stones[n-1]-stones[n-2]-1),(stones[1]-stones[0]-1))
```

接着求最小移动次数，如果最后游戏结束，那么一定有 n 个连续坐标摆满了石子。如果我们要移动最少，必定要找一个石子序列，使得在 n 大小连续的坐标内，初始时有最多的石子。

设想有个尺子，上面有 n个刻度点，我们用这个尺子在石子从最左边到最右边移动，每动一次都查看下在尺子范围内有 m 个石子，那么要使这个区间填满，就需要移动 n-m次。只要在尺子外部有石子，就有策略填满尺子内的。这些次数中最小的就为最少次数。

但是有一个特例：

1，2，3，4，7

这种 1-4 是最好的序列，但是 7 不能移动到端点，只能 1 先移动到 6，然后 7 移动到 5 解决，这种情况要用 2 步。就是尺子内的石子都是连续的，中间没空洞，只在边上有空，要用 2 次。

------

```go
/*
执行用时 :24 ms, 在所有 Go 提交中击败了50.00%的用户
内存消耗 :6 MB, 在所有 Go 提交中击败了100.00%的用户
*/
func numMovesStonesII(stones []int) []int {
    sort.Ints(stones)
    n:=len(stones)
    max:=stones[n-1]-stones[0]+1-n
    max-=tomin((stones[n-1]-stones[n-2]-1),(stones[1]-stones[0]-1))
    min:=max
    i,j:=0,0
    for ;i<n;i++{
        for ;j+1<n&&(stones[j + 1] - stones[i] + 1 <= n);j++{}
        cost:=n-(j+1-i)
        if(j - i + 1 == n - 1 && stones[j] - stones[i] + 1 == n - 1){
            cost = 2
        }
        min = tomin(min, cost);
    }
    return []int{min,max}
}

func tomin(i,j int)int{
    if i<j{
        return i
    }
    return j
}

```

