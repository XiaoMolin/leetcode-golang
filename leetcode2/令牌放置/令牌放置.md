#### [948. 令牌放置](https://leetcode-cn.com/problems/bag-of-tokens/)

难度中等34

你的初始能量为 `P`，初始分数为 `0`，只有一包令牌。

令牌的值为 `token[i]`，每个令牌最多只能使用一次，可能的两种使用方法如下：

- 如果你至少有 `token[i]` 点能量，可以将令牌置为正面朝上，失去 `token[i]` 点能量，并得到 `1` 分。
- 如果我们至少有 `1` 分，可以将令牌置为反面朝上，获得 `token[i]` 点能量，并失去 `1` 分。

在使用任意数量的令牌后，返回我们可以得到的最大分数。

 



**示例 1：**

```
输入：tokens = [100], P = 50
输出：0
```

**示例 2：**

```
输入：tokens = [100,200], P = 150
输出：1
```

**示例 3：**

```
输入：tokens = [100,200,300,400], P = 200
输出：2
```

 

**提示：**

1. `tokens.length <= 1000`
2. `0 <= tokens[i] < 10000`
3. `0 <= P < 10000`





------

#### 思路：贪心算法

如果让我们来玩令牌放置这个游戏，在让令牌正面朝上的时候，肯定要去找能量最小的令牌。同样的，在让令牌反面朝上的时候，肯定要去找能量最大的令牌。

因此我们对数组排序，那么我们只有能量就前面开始让令牌朝上，获取分数，用分数从最后面开始来将令牌置为反面朝上，直到无法进行操作为止。

------

```go
/*
执行用时 :4 ms, 在所有 Go 提交中击败了93.75%的用户
内存消耗 :3 MB, 在所有 Go 提交中击败了100.00%的用户
*/


func bagOfTokensScore(tokens []int, P int) int {
    sort.Ints(tokens)
    right:=len(tokens)-1
    res:=0
    for i:=0;i<=right;i++{
        if tokens[i]<=P{
            res++
            P-=tokens[i]
        }else if res > 0 && i+1 < right{//这里要判断res是否大于零
            P+=tokens[right]
            right-- 
            i--		//这里要回退一步，因为之一步因为能量不够没有翻牌
            res--
        }
    }
    return res
}
```

